// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Integrate
#pragma kernel ComputeForces
#pragma kernel ComputeDensityAndPressure

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWStructuredBuffer<float3> particles;
RWStructuredBuffer<float3> velocities;
RWStructuredBuffer<float3> forces;
RWStructuredBuffer<float> pressures;
RWStructuredBuffer<float> densities;

float DeltaTime;
float Bounce;
float Pi;
float G;
float3 BoundingBox;
float InfluenceRadius;
float InfluenceRadius2;
float InfluenceRadius3;
float InfluenceRadius6;
float InfluenceRadius9;



float sphKernel (float3 diff)
{
    float r2 = dot(diff, diff);
    if (r2 < 0.0001)
    {
        return 1;
    }
    else
    {
        return 1 - sqrt(r2) / 0.1;
    }
}

[numthreads(8,1,1)]
void Integrate (uint3 id : SV_DispatchThreadID)
{
    float3 pos = particles[id.x];
    float3 vel = velocities[id.x];
    float3 force = forces[id.x];
    float density = densities[id.x];
    float pressure = pressures[id.x];


    velocities[id.x] = vel + force * DeltaTime;
    particles[id.x] = pos + vel * DeltaTime;
    forces[id.x] = float3(0, 0, 0);


    // Bounce on walls
    if(particles[id.x].x < -BoundingBox.x/2)
    {
        particles[id.x].x = -BoundingBox.x/2;
        velocities[id.x].x = -velocities[id.x].x * Bounce;
    }
    if(particles[id.x].x > BoundingBox.x/2)
    {
        particles[id.x].x = BoundingBox.x/2;
        velocities[id.x].x = -velocities[id.x].x * Bounce;
    }
    if(particles[id.x].y < -BoundingBox.y/2)
    {
        particles[id.x].y = -BoundingBox.y/2;
        velocities[id.x].y = -velocities[id.x].y * Bounce;
    }
    if(particles[id.x].y > BoundingBox.y/2)
    {
        particles[id.x].y = BoundingBox.y/2;
        velocities[id.x].y = -velocities[id.x].y * Bounce;
    }
    if(particles[id.x].z < -BoundingBox.z/2)
    {
        particles[id.x].z = -BoundingBox.z/2;
        velocities[id.x].z = -velocities[id.x].z * Bounce;
    }
    if(particles[id.x].z > BoundingBox.z/2)
    {
        particles[id.x].z = BoundingBox.z/2;
        velocities[id.x].z = -velocities[id.x].z * Bounce;
    }

    
}

[numthreads(8,1,1)]
void ComputeForces (uint3 id : SV_DispatchThreadID)
{
    float3 pos = particles[id.x];
    float3 vel = velocities[id.x];
    float3 force = forces[id.x];
    float density = densities[id.x];
    float pressure = pressures[id.x];


    forces[id.x] = G * float3(0, -1, 0);
}

[numthreads(8,1,1)]
void ComputeDensityAndPressure (uint3 id : SV_DispatchThreadID)
{
    float3 pos = particles[id.x];
    float3 vel = velocities[id.x];
    float3 force = forces[id.x];
    float density = densities[id.x];
    float pressure = pressures[id.x];
    
    densities[id.x] = 1;
    pressures[id.x] = 1;
}
